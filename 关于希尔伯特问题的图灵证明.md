# 关于的希尔伯特问题的图灵机证明
>### 1. **通用图灵机**是指这样一种机器: 将输入的纸带分成两段, 先输入的第一段为其行为的集合的编码, 后面一段为它输入的值的编码. 图灵机按照第一段的编码内容来操作第二段输入, 最终得到输出
+ 1.1 考虑到读取纸带的原型图灵机的模型是已经达成统一结论的, 读者大概已经知道的东西, 请谅解这里不加以赘述它的定义  
&nbsp;   
+ 1.2 图灵机的行为指的是这样一种东西: **"x1-1->x2-0R"** .  "->" 左边说明了图灵机在x1状态下读取到输入 "1" 的时候触发这个行为, "->" 右边说明了行为的结果,即图灵机状态变为 x2 , 然后将纸带上该位置改写为 "0" , 最后的 R 代表图灵机相对于纸带向右移动. 除此之外, 我们还需要 L 来表示向左移动, STOP  来表示图灵机停机
  + 1.2.1 "x1-1->x2-0R" 只是一个例子, 实际上图灵机的行为可以写成任意形式, 但是必须包含上述的基本信息
  + 1.2.2 这里为了方便, 我们认为纸带上所有数据都是二进制编码的, 即都是 0 和 1 .   
&nbsp; 
+ 1.3 图灵机的行为的集合可以是任意长度, 由任意行为组成. 因此显然并不是所有这样的集合都是能使得图灵机停止的. 这些集合要么缺少STOP符, 要么STOP符所在的行为是不可到达的.
  + 1.3.2 比如 {0-0->0-0R,0-1->0-0R} 这个集合内的行为输入图灵机后, 图灵机只是简单地向右移动并将所有 1 抹成 0 , 且永远不会停下.
  + 1.3.3 而 {0-0->0-0R,0-1->0-1STOP} 输入到图灵机后, 会使其遇到第一个 1 就停下, 而不改变任何东西.  
&nbsp;  
+ 1.4 若给所有行为的集合编号, 可以得到一个无限长的编号数组. 为了方便, 我们**将被输入了编号为 n 的行为集合的通用图灵机称为第 n 台图灵机**.  
&nbsp;    
+ 1.5 图灵机的输出被定义为: 图灵机停机之后, 在纸带上留下的二进制编码数字  
&nbsp;   
+ 1.6 由此, **任何通用图灵机都可以被表述为 `y = T(n , m)`** . 它接受编号为 n 的行为和要处理的数据 m 作为输入, 并在纸带上留下 y 作为输出  
&nbsp;
> ### 2. 希尔伯格问题可以被重述为: 对于任意的 m 与 n, 是否都存在判定 "第 n 台图灵机作用于数 m 时是否能停机" 这个问题的算法 ?  
+ 2.1 希尔伯格问题的原表述为: 是否存在某种回答属于广泛的, 但定义很好的集合的, 所有数学问题的机械步骤  
&nbsp;
+ 2.2 若回答是肯定的, 我们可以合理地推断出它的一个必要条件, 即这个定义完好的系统内所有的数学问题都至少能被机械地判定真假  
&nbsp;
+ 2.3 考虑这样一个事实: 所有逻辑学问题都是命题形式无疑, 而所有非命题形式的数学问题 Y 都可以通过重述成 " Y 是成立的吗" 来将其转变成一个命题  
&nbsp;
+ 2.4 对于任何一个命题, 都可以通过图灵机以这种方式检验其真假: 把命题中包含的所有输入变量放入一个向量内, 然后将这个向量的所有可能情况放入数组内. 考虑到每个输入变量在定义域上都可能取到任意个数, 那么这个这个数组也可能会是无限长的. 最后将这个数组编码成二进制数作为 m 输入给图灵机. 将图灵机的算法设置为检验 m 内每个向量代入命题内是否为真, 若为真则停机. ~~就像不会解题的时候一个一个代数字进去试~~
  + 2.4.1 比如说费马大定理 :" `x^w + y^w = z^w` 在w>2时, 没有正整数解是否成立 ", 其中总共有 [x,y,z,w], 四个变量, 然后将它们组成的向量 [0,0,0,2] [1,0,0,2] ... 放进数组里输入给图灵机 . 若我们一组一组地代这些变量的值进公式里,再在公式成立时让图灵机停下的话, **原来的命题, 便与"这个图灵机是否可以停机"成为了等价的命题**.  
&nbsp;
+ 2.5 由上所述, "是否存在一个能判定所有数学问题真假的算法", 相当于 "对于任意的 m 与 n, 是否都存在判定 '第 n 台图灵机作用于数 m 时是否能停机' 这个问题的算法 ?"
  + 2.5.1 考虑到可以输入任意的命题, 其输入变量编码得到的 m 应该被认为是任意的 
  + 2.5.2 考虑到对于任一个 m , 任意多的命题都可以将其作为输入, 那么 n 的取值也是任意的  
  + *注: 上面2.5.2小节的证明我写得有些奇怪, 但我没能找出问题所在?*   
&nbsp;
> ### 3. 不存在一台通用图灵机, 它能判定第 n 台图灵机作用于 m 时是否能停止
+ 3.1 若存在上述判断停机问题的算法, 那么考虑到通用图灵机的行为集合的编号可以任意长, 使得它必然涵盖了这一算法, 因此必定存在一台图灵机, 能判断这个停机问题.  
&nbsp; 
+ 3.2 对于这个问题, 这样的证明是不好的: 因为如果第 n1 台图灵机在输入 m 后不会停止, 第 n2 台图灵机在判定 n1 是否能停机时, **只能**看第 n1 台图灵机的执行结果, 于是第 n2 台图灵机也不可能停下来. 
  + 3.2.1 这个证明不好的地方在于: 难以证明 "等待第 n1 图灵机的执行结果" 是第 n2 台图灵机进行停机问题判定的唯一手段.  
&nbsp; 
+ 3.3 对于这个问题,应该使用反证法, 即假设第 n2 台图灵机不知道怎么地就能判断出来第 n1 台图灵机是否能停机. 此时前者的输出为 : `T(n2,T(n1,m))` . 
  + 3.3.1 当 T(n1,m) 不停机时, 输出为 0
  + 3.3.2 当 T(n1,m) 可以停机时, 输出为 T(n1,m)  
&nbsp;  
+ 3.4 若将 m 取值 与 n1 相同时, 得到 `T(n2,T(n1,n1))` , 此时对其加上一个常数 c, 得到 `T(n2,T(n1,n1)) + c`   
&nbsp;  
+ 3.5 同样是考虑到通用图灵机的行为集合的编号可以任意长, 使得它必然涵盖了任一算法. 我们可以设第 n3 台图灵机有 `T(n3,n1) = T(n2,T(n1,n1)) + c`. 如果 T(n1,n1) 可以停机 (这当然是可以做到的, 因为你可以把n1这一编号赋予给任一行为集合) , 此时令 n1 取值为 n3, 则得到:  `T(n1,n1) = T(n1,n1) + c` 这一矛盾的结论. 因此假设错误.  
&nbsp;
+ 3.6 由此我们可以得出, 定义完好的数学体系内总存在无法被证明的命题. 希尔伯特的机械化算法代替人类思维的理想是无法实现的.  
&nbsp;
> ### 4. 后语 
+ 4.1 定义完好的系统内所有的数学问题都能被机械地证明. 这只有在这样一种情况下才是可能的: 这个系统可能是封闭的, 即只基于体系内有限的数学公理. 现在这个结果似乎意味着, 数学与逻辑学的公理不会是有限的. 而算法是没办法从一个公理去得到另外一个独立的公理的.  
&nbsp; 
+ 4.2 这些公理从我们的直觉来, 而且为所有人所共享. 那这些不言自明的公理是否有类似的使它们成为公理的形式呢? 答案是否定的. 因为**公理即是其形式本身**  
&nbsp;  
+ 4.3 我们在用上述反证法的时候, 是否有说出一个体系内无法证明的命题所具有的形式呢作为反例呢? 答案是否定的. 由于n1这一编号赋予给任一行为集合, T(n1,n1)并不具有一个特殊的形式

+ iru学识有限, 有什么疏漏/错误的地方, 欢迎提出~